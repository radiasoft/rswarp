import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.collections import PatchCollection
from matplotlib.gridspec import GridSpec
import functools
from warp import field_solvers
from warp import w3d

# TODO: Would be nice to have 'run_once' in a central repository location
# TODO: Formalize grid lines plotting option


def run_once(f):

    @functools.wraps(f)
    def f_pass(*args, **kwargs):
        pass

    @functools.wraps(f)
    def run(self, *args, **kwargs):
        try:
            return f(self, *args, **kwargs)
        finally:
            setattr(self, f.__name__, f_pass)

    return run


class PlotConductors(object):
    # Supported conductor types
    conductor_types = ['Box']

    # Attributes template
    conductor_attributes = {'xcent': None,
                            'ycent': None,
                            'zcent': None,
                            'xsize': None,
                            'ysize': None,
                            'zsize': None,
                            'voltage': None,
                            'permeability': None,
                            'permittivity': None}

    def __init__(self, plot_axes=None, xbounds=None, zbounds=None):
        """
        Class for plotting of conductors in 2D (XZ).
        Will plot conductors in simulation domain on an X vs Z plot.
        Bounds and scaling are automatically determined
        Args:
            plot_axes: Optional matplotlib axes object to pass for plotting. Normally the axes object is
            generated by PlotConductors automatically.
            xbounds (tuple)(xmin, xmax): Optional Set bounds in x for plotting.
            Normally determined from Warp values in memory.
            zbounds (tuple)(zmin, zmax): Optional Set bounds in z for plotting.
            Normally determined from Warp values in memory.
        """
        try:
            self.xmin = w3d.xmmin
            self.xmax = w3d.xmmax
            self.zmin = w3d.zmmin
            self.zmax = w3d.zmmax
        except (NameError, AttributeError):
            try:
                self.xmin = xbounds[0]
                self.xmax = xbounds[1]
                self.zmin = zbounds[0]
                self.zmax = zbounds[1]
            except TypeError:
                raise TypeError("Must assign xbounds and zbounds")

        if xbounds:
            self.xmin = xbounds[0]
            self.xmax = xbounds[1]
        if zbounds:
            self.zmin = zbounds[0]
            self.zmax = zbounds[1]

        # Try to guess an ideal scaling
        if abs(self.xmax - self.xmin) * 1. > 10.:
            self.scale = 1.
        elif abs(self.xmax - self.xmin) * 1e3 > 1.:
            self.scale = 1e3
        elif abs(self.xmax - self.xmin) * 1e6 > 1.:
            self.scale = 1e6
        else:
            self.scale = 1e9

        self.fig = None
        self.plot_axes = plot_axes
        self.legend_axes = None
        self.conductors = []
        self.voltages = []
        self.dielectrics = []
        self.permittivities = []
        self.conductor_patches = None
        self.dielectric_patches = None
        self.conductor_patch_colors = []
        self.dielectric_patch_colors = []
        self.conductor_legend_handles = []
        self.dielectric_legend_handles = []
        self.legend_fontsize = 5
        self.legend_anchor = (2.25, 1.0)

        # Color options
        self.map = plt.cm.seismic
        self.positive_voltage = self.map(15)
        self.negative_voltage = self.map(240)
        self.ground_voltage = 'grey'
        self.variable_voltage_color = True  # If true use color that varies with voltage, else fixed color for +/-

    def __call__(self, solver):
        self.solver = solver
        self.conductor_coordinates(solver)
        self.create_axes()
        self.conductor_collection()
        plt.grid()

    @run_once
    def conductor_coordinates(self, solver):
        """
        Runs logic for finding which conductors can be plotted and run appropriate patch creation functions.
        Args:
            solver: Warp fieldsolver object containing conductors to be plotted.

        Returns:
                None
        """

        # Iterate through all conductor lists in the solver
        for key in solver.installedconductorlists:
            # Iterate through all conductor objects
            for conductor in solver.installedconductorlists[key]:
                # Perform check to make sure this is a conductor the code knows how to handle
                for obj_type in self.conductor_types:
                    if isinstance(conductor, getattr(field_solvers.generateconductors, obj_type)):
                        if conductor.permittivity is None:
                            self.conductors.append(self.set_rectangle_patch(conductor))
                            self.voltages.append(conductor.voltage)
                        if conductor.permittivity is not None:
                            self.dielectrics.append(self.set_rectangle_patch(conductor, dielectric=True))
                            self.permittivities.append(conductor.permittivity)

    def conductor_collection(self):
        # TODO: Once dielectrics register with solver add in loop to append them to dielectric array
        if not self.plot_axes:
            self.create_axes()

        if len(self.voltages) > 0:
            self.set_collection_colors(self.conductor_patch_colors, self.voltages, self.map)

            # Assign patches for conductors to the plot axes
            self.conductor_patches = PatchCollection(self.conductors)
            self.conductor_patches.set_color(self.conductor_patch_colors)
            self.plot_axes.add_collection(self.conductor_patches)

        if len(self.permittivities) > 0:
            self.set_collection_colors(self.dielectric_patch_colors, self.permittivities, plt.cm.viridis)

            # Assign patches for dielectrics to the plot axes
            self.dielectric_patches = PatchCollection(self.dielectrics)
            self.dielectric_patches.set_color(self.dielectric_patch_colors)
            self.dielectric_patches.set_hatch('//')
            self.plot_axes.add_collection(self.dielectric_patches)

            # Setup the legend and set data for legend axes
            self.create_legend()
        if len(self.voltages) > 0:
            cond_legend = self.legend_axes.legend(handles=self.conductor_legend_handles,
                                    bbox_to_anchor=self.legend_anchor,
                                    borderaxespad=0.,
                                    fontsize=self.legend_fontsize,
                                    title='Voltage (V)')
            self.legend_axes.add_artist(cond_legend)
        if len(self.permittivities) > 0:
            diel_legend = self.legend_axes.legend(handles=self.dielectric_legend_handles,
                                    bbox_to_anchor=(self.legend_anchor[0] + 0.05, self.legend_anchor[1] - 0.2),
                                    borderaxespad=0.,
                                    fontsize=self.legend_fontsize,
                                    title='   Relative\nPermittivity')
            self.legend_axes.add_artist(diel_legend)

    def set_collection_colors(self, color_collection, color_values, map):
        # Wanted color scaling to always be red for negative and blue for positive (assuming bl-r colormap)
        # Created custom linear scaling to using halves of color map for +/- consistently, even if only one sign present

        if self.variable_voltage_color:
            # Min/maxes for linear mapping of voltage to colormap
            negative_min = min(color_values)
            try:
                negative_max = max([i for i in color_values if i < 0.])
            except ValueError:
                negative_max = 0.
            try:
                positive_min = min([i for i in color_values if i > 0.])
            except ValueError:
                positive_min = 0.
            positive_max = max(color_values)

            # Perform mapping
            for voltage in color_values:
                if voltage < 0.:
                    try:
                        color = int(-115. / abs(negative_max - negative_min) * voltage - 115. /
                                    abs(negative_max - negative_min) * negative_max + 115.)
                    except ZeroDivisionError:
                        color = 240
                    color_collection.append(map(color))
                elif voltage > 0.:
                    try:
                        color = int(-113. / (positive_max - positive_min) * voltage + 113. /
                                    (positive_max - positive_min) * positive_max + 2)
                    except ZeroDivisionError:
                        color = 15
                    color_collection.append(map(color))
                elif voltage == 0.:
                    color_collection.append('grey')
        else:
            # Just use same color for all + or - voltages
            for voltage in color_values:
                if voltage < 0.:
                    color_collection.append(map(240))
                elif voltage > 0.:
                    color_collection.append(map(15))
                elif voltage == 0.:
                    color_collection.append('grey')

    def set_rectangle_patch(self, conductor, dielectric=False):
        """
        Creates a mpl.patches.Rectangle object to represent a box in the XZ plane.
        Args:
            conductor: Warp conductor object

        Returns:
            mpl.patches.Rectangle object

        """
        try:
            x = conductor.zcent
            y = conductor.xcent
            xlength = conductor.zsize
            ylength = conductor.xsize
        except:
            print "Conductor does not have correct attributes to plot: \n{}".format(conductor)
            return

        xcorner = x - xlength / 2.
        ycorner = y - ylength / 2.
        if dielectric:
            p = patches.Rectangle(
                (xcorner * self.scale, ycorner * self.scale),
                xlength * self.scale,
                ylength * self.scale)
                # fill=False,
                # lw=3,
                # color='k',
                # hatch='/')
        else:
            p = patches.Rectangle(
                (xcorner * self.scale, ycorner * self.scale),
                xlength * self.scale,
                ylength * self.scale)

        return p

    def create_axes(self):
        """
        Sets up the plotting region.
        Returns:
            None
        """

        fig = plt.figure(figsize=(12, 5))
        gs = GridSpec(1, 2, width_ratios=[20, 1])
        ax1 = fig.add_subplot(gs[0, 0])
        ax2 = fig.add_subplot(gs[0, 1])

        ax1.set_xticks(self.solver.zmesh * 1e9)
        ax1.set_yticks(self.solver.xmesh * 1e9)
        ax1.grid()

        ax2.axis('off')

        ax1.set_xlim(self.zmin * self.scale, self.zmax * self.scale)
        ax1.set_ylim(self.xmin * self.scale, self.xmax * self.scale)

        prefix = '($mm$)' * (self.scale == 1e3) + '($\mu m$)' * (self.scale == 1e6) + \
                 '($nm$)' * (self.scale == 1e9) + '($m$)' * (self.scale == 1.)

        ax1.set_xlabel('z ' + prefix)
        ax1.set_ylabel('x ' + prefix)

        self.fig = fig
        self.plot_axes = ax1
        self.legend_axes = ax2

    @run_once
    def create_legend(self):
        voltage_sort = []
        permittivity_sort = []

        for voltage, color in zip(self.voltages, self.conductor_patch_colors):
            if voltage not in voltage_sort:
                legend_artist = patches.Patch(color=color, label=voltage)
                self.conductor_legend_handles.append(legend_artist)
                voltage_sort.append(voltage)

        for permittivity, color in zip(self.permittivities, self.dielectric_patch_colors):
            if permittivity not in permittivity_sort:
                legend_artist = patches.Patch(color=color, label=permittivity, hatch='//')
                self.dielectric_legend_handles.append(legend_artist)
                permittivity_sort.append(permittivity)

        self.conductor_legend_handles = [j for (i, j) in sorted(zip(voltage_sort, self.conductor_legend_handles))]
        self.dielectric_legend_handles = [j for (i, j) in sorted(zip(permittivity_sort,
                                                                     self.dielectric_legend_handles))]

    def set_legend_properties(self, fontsize=5, anchor=(2.25, 1.0)):
        """
        Adjust legend fontsize and anchor position. Can be used to fit legend into plotting region.
        Args:
            fontsize: Fontsize for legend descriptors. Default value: 5.
            anchor (x, y):  Normalized position (0, 1) for legend. Default: (2.25, 1.0)

        Returns:

        """
        self.legend_fontsize = fontsize
        self.legend_anchor = anchor


